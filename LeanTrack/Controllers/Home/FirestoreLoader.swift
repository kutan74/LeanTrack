//
//  FirestoreUpdater.swift
//  LeanTrack
//
//  Created by KUTAN ÇINGISIZ on 23.03.2019.
//  Copyright © 2019 KUTAN ÇINGISIZ. All rights reserved.
//

import Foundation
import FirebaseFirestore

/* In order to remove or update a firestore document we need a documentID which is auto-generated by firestore
 So result allows us to either return an error or data which is string at this case
 Whenever we create a new exercise we return it's documentID to HomeViewController then HomeViewController set it's documentID
 */
enum Result<Value, Error: Swift.Error> {
    case success(String)
    case failure(Error)
}

class FirestoreLoader {
    // Regular Firestore Error Thrown Block
    typealias errorHandlerBlock = (_ handler: Error?) -> Void
    // Throw Firestore error or return String if succeed
    typealias resultHandlerBlock = (Result<String, NSError>) -> Void
    
    // Firestore database
    let db = Firestore.firestore()
    var ref: DocumentReference? = nil
}

// MARK: Create / Update workout sessions
extension FirestoreLoader {
    /**
     Creates a new workout session at firestore path "Workouts"
     
     - Parameter exerciseName: Name of the exercise being added
     - Throws: FirestoreError
     - Returns: DocumentID
    */
    func createNewWorkoutSession(exerciseName: String, then handler: @escaping resultHandlerBlock) {
        let docData: [String: Any] = [
            "exerciseName": exerciseName,
            "date": getCurrentDate()
        ]
        
        ref = db.collection("Workouts").addDocument(data: docData) { err in
            if let err = err {
                handler(.failure(err as NSError))
            } else {
                handler(.success((self.ref?.documentID)!))
            }
        }
    }
    
    /**
     Adds sets to existing workout exercise
     
     - Parameter exercise: Sets of the exercise being added
     - Throws: NSError
     - Returns: Void
     */
    func addWorkoutSet(exercise: ExerciseHeader, then handler: @escaping (Error?) -> Void) {        
        let workoutsRef = db.collection("Workouts")
        let workoutSession = workoutsRef.document(exercise.documentID)
        workoutSession.updateData([
            "sets" : getSetsDictionary(for: exercise)
        ])  { (error) in
            if let err = error {
                print(err.localizedDescription)
                handler(err)
            }else {
                handler(nil)
            }
        }
    }
}

// MARK: Removes an existing exercise by it's documentID
extension FirestoreLoader {
    /**
     Removes exercise permenantly from workout session
     
     - Parameter documentID: Document id of the exercise being removed
     - Throws: NSError
     - Returns: Void
     */
    func removeExerciseFromWorkout(with documentID: String, then handler: @escaping errorHandlerBlock) {
        db.collection("Workouts").document(documentID).delete() { err in
            if let err = err {
                handler(err)
            } else {
                handler(nil)
            }
        }
    }
}

// MARK: Retrieve existing workout sessions
extension FirestoreLoader {
    func haveExistingWorkoutSession(handler: @escaping (Bool) -> Void){
        let docRef = db.collection("Workouts").document(getCurrentDate())
        docRef.getDocument { (document, error) in
            if let document = document, document.exists {
                let dataDescription = document.data().map(String.init(describing:)) ?? "nil"
                handler(true)
            } else {                
                handler(false)
            }
        }
    }
}

// MARK: Helpers
/**
 Since firestore doesn't append dict array properly we should create a [[String : String]] and save it to
 Firebase everytime users wants to adds a new set
 */
extension FirestoreLoader {
    func getSetsDictionary(for workout: ExerciseHeader) -> [[String : String]] {
        var sets : [[String : String]] = []
        for index in 0...workout.sets.count - 1 {
            let set = ["weight" : String(workout.sets[index].weight), "repCount" : String(workout.sets[index].repCount)]
            sets.append(set)
        }
        return sets
    }
    
    func getCurrentDate() -> String{
        let currentDateTime = Date()
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy.MM.dd"
        return formatter.string(from: currentDateTime)
    }
}
